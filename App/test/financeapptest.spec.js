// Generated by Selenium IDE
import { Builder, By, Key, until } from 'selenium-webdriver';
import 'chromedriver';
import assert from 'assert';

describe('finance app test', function() {
  this.timeout(60000) // Increased timeout to 60 seconds
  let driver;

  beforeEach(async function() {
    try {
      driver = await new Builder()
        .forBrowser('chrome')
        .build();
      await driver.manage().setTimeouts({ implicit: 10000 }); // Set implicit wait
    } catch (error) {
      console.error('Error setting up WebDriver:', error);
      throw error;
    }
  });

  afterEach(async function() {
    if (driver) {
      try {
        await driver.quit();
      } catch (error) {
        console.error('Error closing browser:', error);
      }
    }
  });

  // Helper function to wait for and click element
  async function waitAndClick(locator, timeout = 15000) {
    try {
      const element = await driver.wait(until.elementLocated(locator), timeout);
      await driver.wait(until.elementIsVisible(element), timeout);
      await driver.wait(until.elementIsEnabled(element), timeout);
      await driver.executeScript("arguments[0].scrollIntoView(true);", element);
      await driver.sleep(500); // Wait for scroll
      await driver.executeScript("arguments[0].click();", element);
      return element;
    } catch (error) {
      console.error(`Error clicking element ${locator}: ${error}`);
      throw error;
    }
  }

  // Helper function to wait for and type text
  async function waitAndType(locator, text, timeout = 15000) {
    try {
      const element = await driver.wait(until.elementLocated(locator), timeout);
      await driver.wait(until.elementIsVisible(element), timeout);
      await driver.wait(until.elementIsEnabled(element), timeout);
      await driver.executeScript("arguments[0].scrollIntoView(true);", element);
      await driver.sleep(500); // Wait for scroll
      await element.clear();
      await element.sendKeys(text);
      return element;
    } catch (error) {
      console.error(`Error typing text ${text} into element ${locator}: ${error}`);
      throw error;
    }
  }

  // Helper function to wait for elements
  async function waitForElements(locator, minCount = 1, timeout = 15000) {
    try {
      await driver.wait(async () => {
        const elements = await driver.findElements(locator);
        return elements.length >= minCount;
      }, timeout, `Timeout waiting for at least ${minCount} elements matching ${locator}`);
    } catch (error) {
      console.error(`Error waiting for elements ${locator}: ${error}`);
      throw error;
    }
  }

  // Helper function to wait for modal to be hidden
  async function waitForModalToBeHidden(modalId, timeout = 15000) {
    try {
      await driver.wait(async () => {
        const modalElement = await driver.findElement(By.id(modalId));
        const isDisplayed = await modalElement.isDisplayed();
        return !isDisplayed;
      }, timeout);
    } catch (error) {
      console.error(`Error waiting for modal ${modalId} to be hidden: ${error}`);
      throw error;
    }
  }

  // Helper function to handle modal dialog
  async function handleModal(buttonLocator, modalId) {
    try {
      await waitAndClick(buttonLocator);
      await waitForModalToBeHidden(modalId);
      await driver.sleep(1000); // Additional wait for any animations
    } catch (error) {
      console.error(`Error handling modal with button ${buttonLocator}: ${error}`);
      throw error;
    }
  }

  it('should test basic finance app functionality', async function() {
    try {
      console.log('Starting test...');
      
      // Navigate to the application
      await driver.get("https://mani0331.github.io/Personal-Finance-Tracker-Application-/index.html");
      await driver.manage().window().setRect({ width: 1382, height: 744 });
      console.log('Navigated to application');

      // Add Transaction
      console.log('Adding transaction...');
      await waitAndClick(By.linkText("Add Transaction"));
      await waitAndType(By.id("description"), "Test Transaction");
      await waitAndType(By.id("amount"), "1000");
      await waitAndClick(By.css(".btn-primary"));
      console.log('Transaction added');
      
      // Go back
      await waitAndClick(By.css(".btn-secondary"));
      console.log('Returned to main page');

      // Check Transaction History
      console.log('Checking transaction history...');
      await waitAndClick(By.linkText("Transaction History"));
      
      // Wait for transaction table and rows
      await waitForElements(By.css("tr"), 2); // Wait for header row + at least one transaction
      console.log('Transaction found in history');

      // Edit Transaction
      console.log('Editing transaction...');
      await waitAndType(By.css("tr:nth-child(1) > td:nth-child(2) > .form-control"), "Updated Transaction");
      await handleModal(By.css("tr:nth-child(1) .btn-warning"), "updateConfirmationModal");
      console.log('Transaction updated');

      // Delete Transaction
      console.log('Deleting transaction...');
      await handleModal(By.css("tr:nth-child(1) .btn-danger"), "deleteConfirmationModal");
      console.log('Transaction deleted');

      // Check Daily Transaction History
      console.log('Checking daily transaction history...');
      await waitAndClick(By.css(".btn-success"));
      await waitAndClick(By.linkText("Daily Transaction History"));
      await waitAndClick(By.css(".btn"));
      console.log('Daily transaction history checked');

      console.log('Test completed successfully!');
    } catch (error) {
      console.error('Test error:', error);
      // Take screenshot on failure
      try {
        const screenshot = await driver.takeScreenshot();
        const fs = await import('fs');
        await fs.promises.writeFile('test-failure-screenshot.png', screenshot, 'base64');
        console.log('Screenshot saved as test-failure-screenshot.png');
      } catch (screenshotError) {
        console.error('Failed to take screenshot:', screenshotError);
      }
      throw error;
    }
  });
});
